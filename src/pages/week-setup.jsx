import Head from 'next/head';
import { useState, useEffect } from 'react';
import { usePlayers } from '@hooks/players';
import { Draggable, Droppable, DragDropContext } from 'react-beautiful-dnd';
import styles from '@styles/Setup.module.css';
import { playerProfile, court } from '../../public/icons';
import { ScriptSnapshot } from 'typescript';

export default function Home() {
	const { getUsers, updateUser, data, error, isLoading, message } = usePlayers();
	const [dictionary, setDictionary] = useState({});
	const [courts, setCourts] = useState([]);
	const [hall, setHall] = useState([]);
	const [isDragging, setIsDragging] = useState(false);
	const playersPerCourt = 4;

	useEffect(() => {
		getUsers({ approved: true });
	}, []);

	useEffect(() => {
		if (data && data.length > 0) {
			setHall([...data]);

			setDictionary(convertIdToObject([...data]));
			// Calculate the number of courts needed
			const numCourts = Math.ceil(data.length / playersPerCourt);

			// Create an array of courts, each containing an array of players
			const courtsData = new Array(numCourts).fill().map((_, i) => {
				return {
					number: i + 1,
					courtSides: {
						a: '',
						b: '',
						c: '',
						d: '',
					},
				};
			});

			setCourts(courtsData);
		}
	}, [data]);
	function convertIdToObject(inputArray) {
		const result = {};
		inputArray.forEach((item) => {
			const id = item._id;
			if (id) {
				const idValue = id;
				const itemCopy = { ...item };
				delete itemCopy.email;
				delete itemCopy.approved;
				delete itemCopy.partner;
				delete itemCopy.referrer;

				result[idValue] = itemCopy;
			}
		});
		return result;
	}

	const onDragStartHandler = () => {
		setIsDragging(true);
	};

	const onBeforeCaptureHandler = (res) => {
		console.log(res);
	};

	const onDragEndHandler = (res) => {
		const { source, destination, type, draggableId } = res;

		setIsDragging(false);

		if (!destination) return;

		if (type === 'group') {
			const newLineup = [...hall];
			let newCourts = [...courts];
			const sourceIndex = source.index;
			const destinationIndex = destination.index;

			if (source.droppableId !== 'HALL' && destination.droppableId !== 'HALL') {
				const [destinationCourtNumber, destinationCourtSide] = destination.droppableId.split('-');
				const [sourceCourtNumber, sourceCourtSide] = source.droppableId.split('-');
				let sourceSpot = courts[sourceCourtNumber - 1].courtSides[sourceCourtSide];
				let destinationSpot = courts[destinationCourtNumber - 1].courtSides[destinationCourtSide];

				newCourts[destinationCourtNumber - 1].courtSides[destinationCourtSide] = sourceSpot;
				newCourts[sourceCourtNumber - 1].courtSides[sourceCourtSide] = destinationSpot;

				return setCourts(newCourts);
			} else if (destination.droppableId !== 'HALL') {
				const [courtNumber, courtSide] = destination.droppableId.split('-');

				if (!!newCourts[courtNumber - 1].courtSides[courtSide]) return;

				newCourts[courtNumber - 1].courtSides[courtSide] = dictionary[draggableId];
				newLineup.splice(source.index, 1);

				setCourts(newCourts);
			} else if (source.droppableId !== 'HALL' && destination.droppableId === 'HALL') {
				const [courtNumber, courtSide] = source.droppableId.split('-');
				const movedPlayer = newCourts[courtNumber - 1].courtSides[courtSide];

				newLineup.splice(destinationIndex, 0, movedPlayer);
				newCourts[courtNumber - 1].courtSides[courtSide] = '';
				setCourts(newCourts);
			} else {
				const [movedPlayer] = newLineup.splice(sourceIndex, 1);

				newLineup.splice(destinationIndex, 0, movedPlayer);
			}

			return setHall(newLineup);
		}
	};

	const autoFillCourts = (sortBy, direction) => {
		const sortedHall = sortedData(hall, sortBy, direction);
		const newCourts = [...courts];

		sortedHall.forEach((player) => {
			let courtNumber = 0;
			let courtSide;

			while (courtNumber < newCourts.length) {
				const court = newCourts[courtNumber];
				courtSide = ['a', 'b', 'c', 'd'].find((side) => court.courtSides[side] === '');

				if (courtSide !== undefined) {
					court.courtSides[courtSide] = dictionary[player._id];
					console.log(court.courtSides[courtSide]);
					break; // Player assigned, exit the loop
				} else {
					courtNumber++;
				}
			}
			if (courtNumber >= newCourts.length) {
				console.log('All courts are filled, player not assigned.');
			}
		});
		setHall([]);
		return setCourts(newCourts);
	};

	function sortedData(data, sortBy, direction) {
		return [...data].sort((a, b) => {
			if (direction === 'up') return b[sortBy].toString().localeCompare(a[sortBy].toString());
			else return a[sortBy].toString().localeCompare(b[sortBy].toString());
		});
	}

	return (
		<>
			<Head>
				<title>Lineup</title>
				<meta name='description' content='Generated by create next app' />
				<meta name='viewport' content='width=device-width, initial-scale=1' />
				<link rel='icon' href='/favicon.ico' />
			</Head>
			<>
				{isLoading ? (
					<p>Loading...</p>
				) : error ? (
					<p>There has been a server issue.</p>
				) : (
					<div>
						<button onClick={() => autoFillCourts('first_name', 'down')}>Auto Fill</button>
						<DragDropContext
							onDragStart={onDragStartHandler}
							onDragEnd={onDragEndHandler}
							onBeforeCapture={onBeforeCaptureHandler}
						>
							<Droppable droppableId='HALL' type='group' index={1}>
								{(provided) => (
									<div {...provided.droppableProps} ref={provided.innerRef} className={styles.hall}>
										{hall.map((player, i) => (
											<div key={player._id}>
												<Draggable draggableId={player._id.toString()} index={i}>
													{(provided, snapshot) => (
														<div
															className={styles.player}
															{...provided.dragHandleProps}
															{...provided.draggableProps}
															ref={provided.innerRef}
															dragging={JSON.stringify(snapshot.isDragging)}
														>
															{playerProfile}
															<h3>
																{player.first_name} {player.first_name[0]}.
															</h3>
														</div>
													)}
												</Draggable>
											</div>
										))}
										{provided.placeholder}
									</div>
								)}
							</Droppable>
							<div className={styles.courts}>
								{courts.map((court, i) => (
									<div key={court.number + '-A'} courtid={court.number}>
										{['a', 'b', 'c', 'd'].map((courtSide, index) => (
											<Droppable
												key={court.number + '-' + courtSide}
												droppableId={court.number + '-' + courtSide}
												type='group'
												index={index}
												style='background-color: green'
											>
												{(provided) => (
													<div
														className={isDragging ? styles.isAvailable : ''}
														ref={provided.innerRef}
														{...provided.droppableProps}
														busy={(court.courtSides[courtSide] !== '').toString()}
													>
														<Draggable
															draggableId={court.number + '-' + courtSide}
															key={court.number + '-' + courtSide}
															index={index + i}
														>
															{(provided) => (
																<div
																	{...provided.dragHandleProps}
																	{...provided.draggableProps}
																	ref={provided.innerRef}
																	className={styles.player}
																>
																	{court.courtSides[courtSide] ? (
																		<>
																			{playerProfile}
																			<h3>
																				{court.courtSides[courtSide].first_name}{' '}
																				{court.courtSides[courtSide].last_name[0]}.
																			</h3>
																		</>
																	) : null}
																</div>
															)}
														</Draggable>
														{provided.placeholder}
													</div>
												)}
											</Droppable>
										))}
									</div>
								))}
							</div>
						</DragDropContext>
					</div>
				)}
			</>
		</>
	);
}
